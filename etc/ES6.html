<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Title</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h3 id="ecma6">ECMA6</h3>

<ul>
<li><strong>Globális változó: </strong> ez a default</li>
<li><strong>Blokkszintű scope: </strong> let</li>
<li><strong>Funkciószintű scope:</strong> var</li>
<li><strong>Konstans:</strong> const</li>
<li><strong>Cast nélküli equals: </strong> ===</li>
<li><strong>If shorthand: </strong> (x &gt; 0) ? ‘yes’ : ‘no’;</li>
<li><strong>Object prototype: </strong> <code>function Person(name) { this.name = name;}</code></li>
<li><strong>new Array</strong>: <code>var a = new Array(size);</code> or <code>var b = [];</code></li>
<li><strong>loop on array: </strong> <code>for (const v of a){}</code> or <code>a.forEach(function(){});</code></li>
<li><strong>Array functions: </strong> <code>push, pop, join, reverse, shift, slice, sort, splice, concat</code></li>
<li><strong>Multiple params: </strong> <code>..args</code></li>
<li><strong>Object params as functions or Shared functions: </strong> <code>Person.prototype.func = function (){};</code></li>
<li><strong>Closure - állapot elmentése, fvgyártás: </strong> <code> <br>
function makeAdder(a) { return function(b) {  return a + b;  }; } <br>
var x = makeAdder(5); x(6);</code></li>
<li><strong>Default paraméterek: </strong> <code>function(height = 50){}</code></li>
<li><strong>Template literálok és multiline string: </strong> <code>var first = "John"; var name = `Your name is ${first}.`</code></li>
<li><strong>Adat destrukturálás: </strong> <code>var {username, password} = req.body</code></li>
<li><strong>Copy: </strong> <code>var b = Object.create(a)</code></li>
<li><strong>Function shorthand with this closure?: </strong> <code>()=&gt;{}</code></li>
<li><strong>Promise - callback helyett async chain: </strong> <code> <br>
var wait1000 =  ()=&gt; new Promise((resolve, reject)=&gt; {setTimeout(resolve, 1000)}); <br>
// ************ <br>
wait1000() <br>
.then(function() { <br>
console.log('Yay!') <br>
return wait1000() <br>
}) <br>
.then(function() { <br>
console.log('Wheeyee!') <br>
})</code> <br>
<ul><li><strong>Osztályok: </strong> <code> <br>
class baseModel extends XY { <br>
constructor(options = {}) { // class constructor <br>
this.name = 'Base' <br>
this.options = options <br>
} <br>
getName() { console.log(`Class name: ${this.name}`) <br>
} <br>
}</code></li>
<li><strong>Ős hívása: </strong> <code>super()</code></li>
<li><strong>Export és import: </strong> <code> <br>
// in s.js <br>
export var port = 3000 <br>
export function getAccounts(url) {} <br>
// in main.js <br>
import {port, getAccounts} from 's' <br>
console.log(port) // 3000 <br>
</code></li></ul></li>
<li><strong>Computed paramter names </strong></li>
<li><strong>Swap: </strong> <code>[a,b] = [b,a]</code></li>
<li><strong>Destruktúrálással lehet matchelni-validálni is</strong></li>
<li><strong>Static member - shared változo/fv: </strong></li>
<li><strong>Symbol, Generator, Set, Map, WeakSet, WeakMap</strong></li>
<li><strong>Paraméterek felülírása, régiek megtartása: </strong> <code>Object.assign(cél, x)</code></li>
<li><strong>Array.find és Array.findIndex</strong></li>
<li><strong>Math.trunc, sign, isSafe</strong></li>
<li><strong>Reflection, Proxy</strong></li>
</ul></div></body>
</html>